ΜΗΛΑΣ ΙΩΑΝΝΗΣ 1115 2021 00100
ΚΥΡΙΤΣΗΣ ΧΡΗΣΤΟΣ 1115 2021 00075
ΑΝΑΓΝΩΣΤΟΠΟΥΛΟΣ ΔΗΜΗΤΡΙΟΣ 1115 2021 00002

ΓΙΑ ΜΕΤΑΓΛΩΤΤΙΣΗ ΧΡΗΣΙΜΟΠΟΙΟΥΜΕ ΕΝΤΟΛΗ
make

ΓΙΑ ΝΑ ΤΡΕΞΟΥΜΕ ΤΗΝ ΕΦΑΡΜΟΓΗ 
make run
./build/sort_main

ΓΙΑ ΚΑΘΑΡΙΣΜΟ ΑΡΧΕΙΩΝ 
make clean


Η ΣΥΝΑΡΤΗΣΗ MAIN ΔΗΜΙΟΥΡΓΕΙ ΕΝΑ ΑΡΧΕΙΟ ΑΠΟ ΤΙΣ ΕΓΓΡΑΦΕΣ ΠΟΥ ΕΧΟΥΝ ΓΙΝΕΙ DEFINE ΚΑΙ ΑΦΟΥ ΚΑΛΕΣΕΙ ΤΙΣ SORT KAI MERGE ΕΚΤΥΠΩΝΕΙ ΤΟ ΤΕΛΙΚΟ ΑΡΧΕΙΟ ΑΝΑ ΜΠΛΟΚ



sort.c
-bool shouldSwap(Record* rec1,Record* rec2)
ΕΛΕΓΧΟΣ ΓΙΑ ΤΟ ΠΟΙΑ ΕΓΓΡΑΦΗ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΗ (ΠΡΩΤΑ ΕΛΕΓΧΟΥΜΕ ΟΝΟΜΑ ΚΑΙ ΜΕΤΑ ΕΠΩΝΥΜΟ)

-void sort_FileInChunks(int file_desc, int numBlocksInChunk)
ΧΩΡΙΖΟΥΜΕ ΤΟ ΑΡΧΕΙΟ ΣΕ CHUNKS ΚΑΙ ΚΑΛΟΥΜΕ ΤΗ ΣΥΝΑΡΤΗΣΗ sort_Chunk ΓΙΑ ΤΗΝ ΤΑΞΙΝΟΜΗΣΗ ΤΟΥ ΚΑΘΕ ΣΥΡΜΟΥ

-sort_Chunk(CHUNK* chunk)
ΤΑΞΙΝΟΜΕΙ ΤΟ CHUNK ΠΟΥ ΔΟΘΗΚΕ ΜΕ ΒΑΣΗ ΤΟΝ ΑΛΓΟΡΙΘΜΟ ΤΗΣ ΦΥΣΑΛΙΔΑΣ (BUBBLESORT)



chunk.c
-CHUNK_Iterator CHUNK_CreateIterator(int fileDesc, int blocksInChunk)
ΑΡΧΙΚΟΠΟΙΗΣΗ ΜΕΤΑΒΛΗΤΩΝ ITERATOR ΣΤΟ ΠΡΩΤΟ CHUNK ΤΟΥ ΑΡΧΕΙΟΥ ΠΟΥ ΔΟΘΗΚΕ ΚΑΙ ΑΠΟΘΗΚΕΥΣΗ ΧΡΗΣΙΜΩΝ ΠΛΗΡΟΦΟΡΙΩΝ

-int CHUNK_GetNext(CHUNK_Iterator *iterator, CHUNK *chunk)
ΜΕ ΒΑΣΗ ΤΟ ΤΡΕΧΟΝ CHUNK ΤΟΥ ITERATOR ΒΡΙΣΚΟΥΜΕ ΤΟ ΝΕΟ ΜΕ ΤΟ ΠΡΩΤΟ ΚΑΙ ΤΕΛΕΥΤΑΙΟ ΜΠΛΟΚ ΚΑΙ ΑΡΧΙΚΟΠΟΙΟΥΜΕ ΤΑ ΔΕΔΟΜΕΝΑ ΤΟΥ ΕΝΗΜΕΡΩΝΟΝΤΑΣ ΕΝΑ ΔΕΙΚΤΗ
ΤΕΛΟΣ ΕΝΗΜΕΡΩΝΕΤΑΙ ΚΑΙ ΤΟ ΠΕΡΙΕΧΟΜΕΝΟ ΤΟΥ ITERATOR

-int CHUNK_GetIthRecordInChunk(CHUNK* chunk,  int i, Record* record)
ΒΡΙΣΚΟΥΜΕ ΤΟ ΜΠΛΟΚ ΚΑΙ ΣΤΗ ΣΥΝΕΧΕΙΑ ΤΟΠΟΘΕΤΟΥΜΕ ΤΟΝ CURSOR ΜΕ ΣΤΟΧΟ ΝΑ ΛΑΒΟΥΜΕ ΤΟ RECORD ΠΟΥ ΑΝΑΖΗΤΑΜΕ

-int CHUNK_UpdateIthRecord(CHUNK* chunk,  int i, Record record)
ΑΝΤΙΣΤΟΙΧΑ ΒΡΙΣΚΟΥΜΕ ΤΗΝ ΕΓΓΡΑΦΗ ΚΑΙ ΚΑΝΟΥΜΕ ΕΝΗΜΕΡΩΣΗ ΤΟΥ ΠΕΡΙΕΧΟΜΕΝΟΥ ΤΗΣ ΜΕ ΤΗΝ HP_UpdateRecord

-void CHUNK_Print(CHUNK chunk)
ΕΚΤΥΠΩΣΗ ΕΓΓΡΑΦΩΝ CHUNK

-CHUNK_RecordIterator CHUNK_CreateRecordIterator(CHUNK *chunk)
ΑΡΧΙΚΟΠΟΙΕΙ ΤΟ ITERATOR ΣΤΗ ΠΡΩΤΗ ΕΓΓΡΑΦΗ ΤΟΥ ΣΥΡΜΟΥ ΚΑΘΩΣ ΚΑΙ ΤΙΣ ΒΟΗΘΗΤΙΚΕΣ ΜΕΤΑΒΛΗΤΕΣ

-int CHUNK_GetNextRecord(CHUNK_RecordIterator *iterator, Record* record)
ΛΑΜΒΑΝΟΥΜΕ ΤΗΝ ΕΠΟΜΕΝΗ ΕΓΓΡΑΦΗ ΜΕ ΒΑΣΗ ΤΟΝ ITERATOR ΜΕΣΑ ΣΕ ΕΝΑ CHUNK ΚΑΙ ΕΝΗΜΕΡΩΝΟΥΜΕ ΚΑΤΑΛΛΗΛΑ ΤΟΝ ITERATOR

-void CHUNK_DestroyIterator(CHUNK_Iterator *iterator) 
ΜΕ ΤΗ ΧΡΗΣΗ ΤΗΣ FREE ΑΠΕΛΕΥΘΕΡΩΝΕΤΑΙ Ο ΧΩΡΟΣ ΤΟΥ ITERATOR



merge.c
ΧΡΗΣΙΜΟΠΟΙΟΥΜΕ ΕΝΑ ΠΙΝΑΚΑ ΑΠΟ ΔΕΙΚΤΕΣ ΣΕ CHUNK ΚΑΙ ΕΝΑ ΠΑΡΑΛΛΗΛΟ ΠΙΝΑΚΑ ΑΚΕΡΑΙΩΝ cursor ΚΑΙ ΦΕΡΝΟΥΜΕ ΚΑΘΕ ΦΟΡΑ ΕΝΑ ΝΕΟ CHUNK ΣΤΟ ΔΙΑΘΕΣΙΜΟ ΧΩΡΟ ΤΗΣ ΜΝΗΜΗΣ(ΜΕ ΒΑΣΗ BWAY)
Ο cursor ΔΕΙΧΝΕΙ ΣΤΗΝ ΤΡΕΧΟΥΣΑ ΕΓΓΡΑΦΗ ΤΟΥ ΚΑΘΕ ΣΥΡΜΟΥ ΚΑΙ ΕΝΤΟΠΙΖΟΥΜΕ ΤΗΝ ΜΙΚΡΟΤΕΡΗ ΕΓΓΡΑΦΗ ΜΕ ΒΑΣΗ ΤΟΥΣ CURSORS(shouldSwap) ΚΑΙ ΤΗΝ ΕΙΣΑΓΟΥΜΕ ΣΤΟ ΝΕΟ ΑΡΧΕΙΟ
Ο ΑΝΤΙΣΤΟΙΧΟΣ cursor ΠΡΟΧΩΡΑΕΙ ΣΤΗΝ ΕΠΟΜΕΝΗ ΕΓΓΡΑΦΗ (cursor++) ΕΝΩ ΑΝ ΕΙΣΗΧΘΗ Η ΤΕΛΕΥΤΑΙΑ ΕΓΓΡΑΦΗ ΤΟΥ ΣΥΡΜΟΥ (cursor=-1) ΥΠΟΔΕΙΚΝΥΟΝΤΑΣ ΟΤΙ ΜΠΟΡΟΥΜΕ ΝΑ ΛΑΒΟΥΜΕ ΤΟ ΕΠΟΜΕΝΟ CHUNK
Η ΠΑΡΑΠΑΝΩ ΔΙΑΔΙΚΑΣΙΑ ΕΠΑΝΑΛΑΜΒΑΝΕΤΑΙ ΜΕΧΡΙ ΝΑ ΕΞΑΝΤΛΗΘΟΥΝ ΟΛΕΣ ΟΙ ΕΓΓΡΑΦΕΣ ΟΛΩΝ ΤΩΝ ΣΥΡΜΩΝ



Η ΣΥΝΑΡΤΗΣΗ SORT ΔΟΥΛΕΥΕΙ ΚΑΝΟΝΙΚΑ ΩΣΤΟΣΟ ΑΝΤΙΜΕΤΟΠΙΣΑΜΕ ΚΑΠΟΙΑ ΠΡΟΒΛΗΜΑΤΑ ΣΤΗΝ ΑΝΑΠΤΥΞΗ ΤΗΣ MERGE Η ΟΠΟΙΑ ΔΕΝ ΛΕΙΤΟΥΡΓΕΙ ΜΕ ΟΛΑ ΤΑ ΣΕΝΑΡΙΑ ΕΚΤΕΛΕΣΗΣ
ΣΥΓΚΕΚΡΙΜΕΝΑ ΑΝ Ο ΑΡΙΘΜΟΣ ΤΩΝ ΕΓΓΡΑΦΩΝ ΑΥΞΗΘΕΙ ΚΑΤΑ ΠΟΛΥ ΚΑΙ ΜΕ ΒΑΣΗ ΤΟ bWay ΕΝΤΟΠΙΖΟΥΜΕ ΚΑΠΟΙΕΣ ΑΤΕΛΕΙΕΣ ΣΤΟ ΤΕΛΟΣ ΤΟΥ ΤΕΛΕΥΤΑΙΟΥ ΑΡΧΕΙΟΥ



ΓΕΝΙΚΩΣ ΧΡΗΣΙΜΟΠΟΙΗΣΑΜΕ 2 ΣΥΝΟΜΙΛΙΕΣ ΓΙΑ ΤΗΝ ΑΝΑΠΤΥΞΗ ΤΟΥ ΠΡΟΓΡΑΜΜΑΤΟΣ ΚΑΙ ΓΙΑ ΝΑ ΕΧΟΥΜΕ ΜΙΑ ΠΙΟ ΠΛΗΡΗ ΕΙΚΟΝΑ ΡΩΤΩΝΤΑΣ ΓΙΑ ΤΙΣ ΣΥΝΑΡΤΗΣΕΙΣ ΤΟΣΟ ΣΤΗ ΠΡΩΤΗ ΟΣΟ ΚΑΙ ΣΤΗ ΔΕΥΤΡΕΡΗ ΣΥΝΟΜΙΛΙΑ
https://chat.openai.com/share/271f3648-3a34-4991-a6c7-b4c2a45983e4
https://chat.openai.com/share/2c7c7aa2-006e-48cc-8831-fb4a73ce4950

ΓΙΑ ΤΗ SORT ΕΛΗΦΘΗ ΚΥΡΙΩΣ ΥΠΟΨΗ
https://chat.openai.com/share/271f3648-3a34-4991-a6c7-b4c2a45983e4

ΓΙΑ ΤΗ MERGE ΛΑΒΑΜΕ ΠΛΗΡΟΦΟΡΙΕΣ ΚΑΙ ΙΔΕΕΣ ΑΠΟ ΔΙΑΦΟΡΕΣ ΑΠΑΝΤΗΣΕΙΣ ΤΩΝ ΣΥΝΟΜΙΛΙΩΝ ΚΑΙ ΚΡΑΤΗΣΑΜΕ ΤΗΝ ΙΔΑΝΙΚΟΤΕΡΗ ΚΑΝΟΝΤΑΣ ΟΜΩΣ ΑΡΚΕΤΕΣ ΑΛΛΑΓΕΣ

ΟΙ ΕΠΙΜΕΡΟΥΣ ΣΥΝΑΡΤΗΣΕΙΣ ΔΕΝ ΧΡΕΙΑΣΤΗΚΑΝ ΙΔΙΑΙΤΕΡΕΣ ΤΡΟΠΟΠΟΙΗΣΕΙΣ ΠΕΡΑ ΑΠΟ ΚΑΠΟΙΕΣ ΜΙΚΡΕΣ ΑΛΛΑΓΕΣ ΣΕ ΣΥΝΘΗΚΕΣ(ΠΧ > ΑΝΤΙ >=) ΚΑΙ ΤΗΝ ΠΡΟΣΘΗΚΗ ΤΩΝ ΑΠΑΡΑΙΤΗΤΩΝ ΚΛΗΣΕΩΝ ΤΗΣ HP_Unpin META ΑΠΟ ΤΙΣ ΑΝΤΙΣΤΟΙΧΕΣ HP_GetRecord ΚΑΙ HP_UpdateRecord
ΕΝΩ ΠΡΟΣΘΕΣΑΜΕ ΚΑΙ ΔΙΚΟ ΜΑΣ ΚΩΔΙΚΑ ΓΙΑ ΤΗΝ ΜΕΤΡΗΣΗ ΕΓΓΡΑΦΩΝ ΜΕΣΑ ΣΕ ΚΑΘΕ CHUNK ΤΟ ΟΠΟΙΟ ΠΑΡΕΛΕΙΠΕ ΤΟ GPT

